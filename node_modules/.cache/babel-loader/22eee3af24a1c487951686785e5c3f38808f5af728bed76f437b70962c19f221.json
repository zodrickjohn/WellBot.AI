{"ast":null,"code":"import { Vector2, Matrix4 } from \"three\";\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 5e-3\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tNormal;\n    uniform sampler2D tDepth;\n    uniform sampler2D tNoise;\n\n    uniform vec3 kernel[ KERNEL_SIZE ];\n\n    uniform vec2 resolution;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform mat4 cameraProjectionMatrix;\n    uniform mat4 cameraInverseProjectionMatrix;\n\n    uniform float kernelRadius;\n    uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n    uniform float maxDistance; // avoid the influence of fragments which are too far away\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getDepth( const in vec2 screenPosition ) {\n\n    \treturn texture2D( tDepth, screenPosition ).x;\n\n    }\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    float getViewZ( const in float depth ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#endif\n\n    }\n\n    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n    \tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n    \tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n    \tclipPosition *= clipW; // unprojection.\n\n    \treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n    }\n\n    vec3 getViewNormal( const in vec2 screenPosition ) {\n\n    \treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n    }\n\n    void main() {\n\n    \tfloat depth = getDepth( vUv );\n    \tfloat viewZ = getViewZ( depth );\n\n    \tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n    \tvec3 viewNormal = getViewNormal( vUv );\n\n     vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n    \tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\n    // compute matrix used to reorient a kernel vector\n\n    \tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n    \tvec3 bitangent = cross( viewNormal, tangent );\n    \tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n     float occlusion = 0.0;\n\n     for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n    \t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n    \t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n    \t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n    \t\tsamplePointNDC /= samplePointNDC.w;\n\n    \t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n    \t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n    \t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n    \t\tfloat delta = sampleDepth - realDepth;\n\n    \t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n    \t\t\tocclusion += 1.0;\n\n    \t\t}\n\n    \t}\n\n    \tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n    \tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n    }\n  `)\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n    \tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n    }\n  `)\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    uniform sampler2D tDiffuse;\n\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n    \tfloat result = 0.0;\n\n    \tfor ( int i = - 2; i <= 2; i ++ ) {\n\n    \t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n    \t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n    \t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n    }\n  `)\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };","map":{"version":3,"names":["SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","Vector2","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","fragmentShader","SSAODepthShader","SSAOBlurShader"],"sources":["D:\\WellBot.AI\\node_modules\\src\\shaders\\SSAOShader.ts"],"sourcesContent":["import { Matrix4, Vector2 } from 'three'\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nexport const SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32,\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 0.005 },\n    maxDistance: { value: 0.05 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tNormal;\n    uniform sampler2D tDepth;\n    uniform sampler2D tNoise;\n\n    uniform vec3 kernel[ KERNEL_SIZE ];\n\n    uniform vec2 resolution;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform mat4 cameraProjectionMatrix;\n    uniform mat4 cameraInverseProjectionMatrix;\n\n    uniform float kernelRadius;\n    uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n    uniform float maxDistance; // avoid the influence of fragments which are too far away\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getDepth( const in vec2 screenPosition ) {\n\n    \treturn texture2D( tDepth, screenPosition ).x;\n\n    }\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    float getViewZ( const in float depth ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#endif\n\n    }\n\n    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n    \tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n    \tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n    \tclipPosition *= clipW; // unprojection.\n\n    \treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n    }\n\n    vec3 getViewNormal( const in vec2 screenPosition ) {\n\n    \treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n    }\n\n    void main() {\n\n    \tfloat depth = getDepth( vUv );\n    \tfloat viewZ = getViewZ( depth );\n\n    \tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n    \tvec3 viewNormal = getViewNormal( vUv );\n\n     vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n    \tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\n    // compute matrix used to reorient a kernel vector\n\n    \tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n    \tvec3 bitangent = cross( viewNormal, tangent );\n    \tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n     float occlusion = 0.0;\n\n     for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n    \t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n    \t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n    \t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n    \t\tsamplePointNDC /= samplePointNDC.w;\n\n    \t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n    \t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n    \t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n    \t\tfloat delta = sampleDepth - realDepth;\n\n    \t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n    \t\t\tocclusion += 1.0;\n\n    \t\t}\n\n    \t}\n\n    \tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n    \tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n    }\n  `,\n}\n\nexport const SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n    \tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n    }\n  `,\n}\n\nexport const SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n    \tfloat result = 0.0;\n\n    \tfor ( int i = - 2; i <= 2; i ++ ) {\n\n    \t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n    \t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n    \t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n    }\n  `,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}